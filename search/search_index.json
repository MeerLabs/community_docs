{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Community Documents Site","text":"<p>The Qitmeer community offers documentation and tutorials on Qitmeer, which is maintained and developed by blockchain and open-source enthusiasts.</p> <p>Upload any static assets (images, GIFs etc.) to the community docs repository on GitHub: Meer Labs Community Docs Assets</p> <p>Qitmeer is a blockDAG-based public blockchain infrastructure built on PoW. It features a UTXO-based account system and also supports a compatible EVM for the deployment of smart contracts. Qitmeer has a roadmap to support L2 ZK-rollups and other consensus algorithms in the future.</p> <p> Qitmeer Technical Summary \u2013  5m \u2013 A brief technical summary of the Qitmeer architecture, its advantages over traditional blockchain networks and an overview Qitmeer's EVM compatible layer: QNG.</p> <p>For any questions or news regarding Qitmeer, join our UK Developer Telegram Group:</p> <p> Meer Labs (UK Developer) </p>"},{"location":"#name-conventions","title":"Name Conventions","text":"<p>Name conventions used in the Qitmeer blockchain system and networks are as follows:</p> <ul> <li> <p>Qitmeer: the name of the BlockDAG architecture with POW consensus based qitmeer blockchain infrastructure. It provides a stable, secure, and fair decentralized infrastructure for upper layer applications.</p> </li> <li> <p>QNG: an EVM (Ethereum Virtual Machine) compatible blockchain layer that runs seamlessly with \u201cQitmeer\u201d infrastructure. It provides an easy interface to deploy any EVM compatible dAPPs.</p> </li> <li> <p>Amana: layer 2 solution for QNG, designed to provide high performance and scalability. Currently, Amana is only available on testnet and is based on a Proof of Authority (PoA) consensus algorithm.</p> </li> </ul>"},{"location":"#supporting-websites","title":"Supporting Websites:","text":"<ul> <li>GitHub Repo</li> <li>Qitmeer - Mainnet</li> <li>QNG - Mainnet</li> <li>Qitmeer - Testnet</li> <li>QNG - Testnet</li> </ul>"},{"location":"#key-community-documents","title":"Key Community Documents","text":"<ul> <li>What is BlockDAG</li> <li>Install and run Qitmeer Testnode</li> <li>QNG and Deploying Smart Contracts</li> <li>Solidity Tutorial (Part 1)</li> <li>Solidity Tutorial (Part 2)</li> <li>Solidity Tutorial (Part 3)</li> <li>Deploy Private Amana Network</li> <li>Deploy Private Amana Network (AWS)</li> </ul> <p>For latest Qitmeer project source code visit Qitmeer/QNG.</p>"},{"location":"AWS_deploy_amana_privnet/","title":"AWS - Deploy Amana Privnet","text":"<p>A public AMI (Amazon Machine Image) has been created to allow the quick deployment of EC2 instances with Amana nodes and all its dependencies already preconfigured. </p> <p>To launch an EC2 instance with the Amana Privnet AMI, on the EC2 Management console, click on Launch instances. In the section Application and OS Images (Amazon Machine Image), click on Browse more AMIs. </p> <p>In the search bar, type in \u201cMeer Labs - Amana Privnet\u201d or the AMI ID, \u201cami-07aca94d110e01229\u201d and click on the Community AMIs tab. You should see a single AMI entry labelled \"Meer Labs - Amana Privnet\u201d</p> <p></p> <p>Click select and enter the remaining configuration details for your EC2 instance.</p> <p>\u26a0\ufe0f The size of the EBS volumes (storage) must be set to at least 20 GiB. This is due to the first instance which created this AMI being configured with a storage space of 20 GiB.</p> <p>\u26a0\ufe0f The minimum instance type that may be able to run all three nodes inside one instance is the <code>t3.micro</code>. Although it is recommended to pick an instance type larger than this such as <code>t3.small</code> or <code>t3.medium</code>.</p>"},{"location":"AWS_deploy_amana_privnet/#running-amana-nodes","title":"Running Amana Nodes","text":"<p>When first running your EC2 instance, you should find a directory called <code>qng_privnet</code> where the nodes for the Amana network reside. Inside, will contain the directories <code>node1</code>, <code>node2</code> and <code>node3</code> each preconfigured with their own configuration files. There should also be a JSON file called <code>private_keys.json</code> which contains all the addresses and private keys for each of the nodes.</p> <p>To run a node, enter the directory for the node you wish to run and enter the command: <code>./qng -A ./ -C &lt;config-file&gt;.toml</code>. Each node will have its own uniquely named <code>config.toml</code> file. </p> <pre><code>cd ~/qng_privnet\ncd node1\n./qng -A ./ -C config_1.toml\n\n2023-10-01|05:11:50.672 [INFO ] System info                         QNG Version=1.1.0+dev-bde9231-dirty Go version=go1.20.8\n2023-10-01|05:11:50.711 [INFO ] System info                         Home dir=./\n2023-10-01|05:11:50.712 [INFO ] Loading block database              module=LCDB dbPath=/home/ubuntu/qng_privnet/node1/data/privnet/blocks_ffldb\n2023-10-01|05:11:50.730 [INFO ] Block database loaded               module=LCDB\n2023-10-01|05:11:50.731 [INFO ] transaction index is enabled        module=INDEX\n2023-10-01|05:11:50.732 [INFO ] anticone size:4                     module=DAG\n2023-10-01|05:11:50.735 [INFO ] Meer chain                          module=MEER  version=meervm-v0.0.2\n2023-10-01|05:11:50.939 [INFO ] New local node record               seq=1696137110938 id=b708dc642e50c371 ip=127.0.0.1 udp=8538 tcp=0\n2023-10-01|05:11:50.949 [INFO ] Prepare meereth on NetWork(8133)... \n2023-10-01|05:11:50.950 [INFO ] Maximum peer count                  ETH=0 LES=0 total=0\n2023-10-01|05:11:50.952 [INFO ] Smartcard socket not found, disabling err=\"stat /run/pcscd/pcscd.comm: no such file or directory\"\n2023-10-01|05:11:50.956 [WARN ] Sanitizing cache to Go's GC limits  provided=4096 updated=313\n2023-10-01|05:11:50.957 [INFO ] Set global gas cap                  cap=50000000\n2023-10-01|05:11:50.957 [INFO ] Initializing the KZG library        backend=gokzg\n2023-10-01|05:11:51.151 [INFO ] Allocated trie memory caches        clean=46.00MiB dirty=78.00MiB\n2023-10-01|05:11:51.151 [INFO ] Defaulting to pebble as the backing database \n2023-10-01|05:11:51.152 [INFO ] Allocated cache and file handles    database=/home/ubuntu/qng_privnet/node1/data/privnet/meereth/chaindata cache=156.00MiB handles=524288\n2023-10-01|05:11:51.199 [INFO ] Opened ancient database             database=/home/ubuntu/qng_privnet/node1/data/privnet/meereth/chaindata/ancient/chain readonly=false\n2023-10-01|05:11:51.201 [INFO ] Initialising Ethereum protocol      network=8133 dbversion=&lt;nil&gt;\n2023-10-01|05:11:51.201 [INFO ] Writing custom genesis block \n2023-10-01|05:11:52.368 [INFO ] Persisted trie from memory database nodes=36705 size=3.41MiB time=156.475635ms gcnodes=0 gcsize=0.00B gctime=0s livenodes=0 livesize=0.00B\n</code></pre> <p>If the nodes are running successfully, you should see an output like this:</p> <pre><code>2023-10-01|05:13:53.007 [INFO ] Imported new chain segment          number=9 hash=bbf56d..954f8c                                                     blocks=1 txs=0 mgas=0.000 elapsed=357.829\u00b5s mgasps=0.000 dirty=0.00B\n2023-10-01|05:13:53.008 [INFO ] Commit new sealing work             number=10 sealhash=688fd9..dc6e55 uncles=0 txs=0 gas=0 fees=0 elapsed=239.493\u00b5s\n2023-10-01|05:13:53.009 [INFO ] Commit new sealing work             number=10 sealhash=688fd9..dc6e55 uncles=0 txs=0 gas=0 fees=0 elapsed=821.172\u00b5s\n2023-10-01|05:13:56.001 [INFO ] Successfully sealed new block       number=10 sealhash=688fd9..dc6e55 hash=c526d9..7ada52                                                     elapsed=2.992s\n2023-10-01|05:13:56.001 [INFO ] \ud83d\udd28 mined potential block             number=10 hash=c526d9..7ada52\n2023-10-01|05:13:56.002 [INFO ] Commit new sealing work             number=11 sealhash=82e681..6cc56c uncles=0 txs=0 gas=0 fees=0 elapsed=655.949\u00b5s\n2023-10-01|05:13:56.003 [WARN ] Block sealing failed                err=\"signed recently, must wait for others\"\n2023-10-01|05:13:56.003 [INFO ] Commit new sealing work             number=11 sealhash=82e681..6cc56c uncles=0 txs=0 gas=0 fees=0 elapsed=2.259ms\n2023-10-01|05:13:59.002 [INFO ] Imported new chain segment          number=11 hash=64c417..9a54b6                                                     blocks=1 txs=0 mgas=0.000 elapsed=285.388\u00b5s mgasps=0.000 dirty=0.00B\n2023-10-01|05:13:59.003 [INFO ] Commit new sealing work             number=12 sealhash=ae4064..8a92e9 uncles=0 txs=0 gas=0 fees=0 elapsed=202.539\u00b5s\n2023-10-01|05:13:59.004 [INFO ] Commit new sealing work             number=12 sealhash=ae4064..8a92e9 uncles=0 txs=0 gas=0 fees=0 elapsed=1.019ms\n2023-10-01|05:13:59.298 [INFO ] Looking for peers                   peercount=2 tried=0 static=0\n2023-10-01|05:14:02.002 [INFO ] Imported new chain segment          number=12 hash=ea2ec4..78ffc8\n</code></pre> <p>\u26a0\ufe0f The instructions here are only applicable for running multiple nodes locally on one EC2 instance. If you wish to run the nodes on separate instances, than you must make certain changes to the networking configuration. This may include changes to the config file as well as changes to your EC2 Security Groups.</p>"},{"location":"Installation_Running_qng_node/","title":"Installation and Running Testing Qitmeer Node","text":""},{"location":"Installation_Running_qng_node/#prerequisites","title":"Prerequisites","text":"<ul> <li>Golang (Go) - Download and installation can be found at: https://go.dev/doc/install</li> </ul>"},{"location":"Installation_Running_qng_node/#compile-and-build-meer-node","title":"Compile and build MEER node","text":"<ul> <li>Clone the repository: <code>git clone https://github.com/Qitmeer/qng.git</code></li> <li>Enter the <code>qng</code> directory: <code>cd qng</code></li> <li>Run <code>make</code> command</li> </ul> <pre><code>&gt; git clone https://github.com/Qitmeer/qng.git\n&gt; cd qng\n&gt; make\n</code></pre> <p>Running <code>make all</code> will also install qx, relay and fastIBD</p>"},{"location":"Installation_Running_qng_node/#install-qx","title":"Install qx","text":"<p>qx is a command-line tool and can be regarded as the \u201cSwiss Army Knife of Qitmeer\u201d. It can provide a range of functionalities such as: random seed generation, public/private key generation, constructing transactions etc.</p>"},{"location":"Installation_Running_qng_node/#installation-instructions","title":"Installation Instructions:","text":"<p>This process can be skipped if you ran the <code>make all</code> command in the previous section.</p> <ul> <li>Enter the <code>qng/cmd/qx</code> directory: <code>cd qng/cmd/qx</code></li> <li>Run <code>go build</code> (you may have to run <code>go mod tidy</code> if you run into issues regarding dependencies)</li> <li>To run the tool, simply type <code>./qx</code></li> </ul> <pre><code>&gt; cd qng/cmd/qx\n&gt; go build\n&gt; ./qx\n</code></pre> <p>Installation of qx is not mandatory but may prove to be useful to complete certain tasks</p>"},{"location":"Installation_Running_qng_node/#create-wallet-kahf-wallet","title":"Create Wallet (KAHF Wallet)","text":"<p> - Download and install the app KAHF wallet available at: https://www.kahf.io/. KAHF is a multi-chain wallet that provides a user-friendly GUI to manage all your digital assets. After following the instructions on-screen, ensure that Qitmeer Testnet is also selected in order to manage assets in the Qitmeer test network environment.</p>"},{"location":"Installation_Running_qng_node/#export-private-key","title":"Export Private Key","text":"<p>Using the app, you will also be able to export your private key:</p> <p>1) Click on the icon on the top-right hand corner:</p> <p></p> <p>2) Select Check Private Key and enter in your password 3) Select Qitmeer Testnet Assets (UTXO) 4) Your private key should now be displayed. You also have the option to press Copy to copy to your clipboard</p>"},{"location":"Installation_Running_qng_node/#create-wallet-using-qx","title":"Create Wallet (Using qx)","text":"<p>You can use the qx command line to generate your own wallet:</p> <ul> <li>Enter the directory where you have placed the qx binary file (if you followed the previous instructions above, this should be at <code>qng/cmd/qx</code></li> <li>Generate a cryptographic secure pseudo-random entropy (seed) using the command <code>./qx entropy</code></li> </ul> <pre><code>&gt; ./qx entropy\nOutput: 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28\n</code></pre> <p>To produce a mnemonic word-list (BIP39) enter the command:</p> <p><pre><code>&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28\nOutput: museum region tiny moral whale final humble help race crop smart drift fortune real sheriff correct price antique ribbon venture tiny system weather all\n</code></pre> With this mnemonic, you can export your wallet to KAHF wallet or any other compatible wallet.</p> <p>Use the following commands to generate the Private Key, Public Key, Address, Public Key (PK) Address and ETH Address:</p> <p>WARNING: The entropy and other values generated here, exist purely for demonstration purposes. These values should only be used in a test environment and not used to hold assets with real monetary value.</p> <p>Private Key: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new\nOutput: 12d76cda3b0d4dde6c8cad7f0df2ceb5b1690b4f3725f94226095cf04d3f21e2\n</code></pre> Public Key: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public\nOutput: 0363e43e0dfda44a34e1653f4feeb487fa8ccb88ba5b975a888913190e4a94abcd\n</code></pre> Address: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-addr -v &lt;network&gt;\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-addr -v testnet\nOutput: TnP7hbozSYpv8vPzHFnVfwVSJR9hhgoW5P7\n</code></pre> Public Key Address: <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-pkaddr -v testnet\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-pkaddr -v testnet\nOutput: Tk6ts4JPqiyS5Xn1Jh9XmjADDtnBMDpoDCbcMKV2FkeGqjDJb1azt\n</code></pre></p> <p>The <code>-v</code> flag represents the type of network. By default this is set to \"mainnet\". </p> <p>ETH Address (for use in MeerEVM): <pre><code>&gt; ./qx mnemonic-new &lt;entropy&gt; | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-ethaddr\n&gt; ./qx mnemonic-new 91b69389c7df9aad1bbb58b0667f322165b965f16184aa613ee4792e27b9be28 | ./qx mnemonic-to-seed | ./qx ec-new | ./qx ec-to-public | ./qx ec-to-ethaddr\nOutput: 0x86209f32b6490Ca551b09fb4c8f70B79f513cF73\n</code></pre></p>"},{"location":"Installation_Running_qng_node/#commands-list","title":"Commands List:","text":"<ul> <li><code>mnemonic-new</code>:  create a mnemonic word-list (BIP39) from an entropy</li> <li><code>mnemonic-to-seed</code>: convert a mnemonic word-list (BIP39) to its 512 bits seed</li> <li><code>ec-new</code>: create a new Elliptic Curve (EC) private key from an entropy (seed)</li> <li><code>ec-to-public</code>: derive the EC public key from a EC private key</li> <li><code>ec-to-addr</code>:  convert an EC public key to a payment address</li> <li><code>ec-to-pkaddr</code>: convert an EC public key to a payment public key address</li> <li><code>ec-to-ethaddr</code>: convert an EC public key to a Ethereum address</li> </ul>"},{"location":"Installation_Running_qng_node/#mining-test-coins","title":"Mining Test Coins","text":"<p>There are several ways in which to mine MEER test coins for use in the Qitmeer testnet. Regardless of which method is used, the MEER node must have the <code>--miner</code> flag enabled as well as <code>--miningaddr=&lt;block-reward-address&gt;</code>. </p> <p>If the block reward were to be sent to address \"TnSh92n7s4XbRiPmNrtYDttMugLVycsuars\", then the flag would be <code>--miningaddr=TnSh92n7s4XbRiPmNrtYDttMugLVycsuars</code>. Both the address and PK address can be used when setting this flag.</p> <p>These include:  - Inserting the <code>--generate</code> flag before running the MEER node. <code>./qng \u2013-testnet \u2013-miner \u2013-miningaddr=&lt;block-reward-address&gt; \u2013-generate</code>. This method is the easiest to implement and will attempt to mine blocks using the onboard CPU.  - Installing and running the qitmeer-miner. This method provides a greater level of control of the mining process allowing users to utilise their GPU for mining instead of their CPU, participate as a solo miner or as part of a pool etc</p> <p>Once you have successfully received miner reward and obtained some test coins, you can view the balance of your account on the Qitmeer BlockDAG Explorer Testnet or KAHF Wallet. </p>"},{"location":"What_is_BlockDAG/","title":"What is BlockDAG?","text":"<p>The Qitmeer network utilises a blockDAG structure as opposed to the traditional blockchain structure found in most popular Distributed Ledger Technology (DLT). Although the terms blockchain and blockDAG are often used interchangeably, they are entirely different data structures (they may retain some similar features as in Qitmeer\u2019s case which will be discussed later on). </p>"},{"location":"What_is_BlockDAG/#dag-directed-acyclic-graph","title":"DAG - Directed Acyclic Graph","text":"<p>Before we delve into what blockDAG is, we need to address, what the \u201cDAG\u201d part stands for. DAG is an acronym for:</p> <p>D - Directed</p> <p>A - Acyclic</p> <p>G - Graph</p> <p>DAG is simply a directed graph containing nodes and edges which have no cycles. DAGs themselves are not a brand new concept and have already seen widespread applications in biology, computer science and even the widely popular version control system - Git. </p> <p></p> <p>Fig 1. An example of a DAG</p>"},{"location":"What_is_BlockDAG/#bitcoin-security-scalability-problem","title":"Bitcoin Security-Scalability Problem","text":"<p>Bitcoin, one of the earliest and most popular forms of cryptocurrency has over the years proved to be very secure with the underlying security of the network remaining intact. However, whilst its greatest strength may lie in its security, this has come at a tradeoff when it comes to its scalability. </p> <p>Most notably:</p> <ul> <li>Bitcoin is slow\u2026very slow with 5-7 TPS (Transactions Per Second)</li> <li>Block size is restricted to \u22481MB (post-Segwit this has a practical limit of about \u22482MB)</li> <li>Block creation time is restricted to 1 block \u2248 10 minutes</li> </ul> <p>Whilst these parameters might seem impractical, it is because of this impracticality that has made Bitcoin soo secure. In theory, by increasing the block size or creation time, the longer it will take for these blocks to propagate through the network. Since nodes may not have access to the most recent block on the network, they will continue mining on what they perceive is the current block. Once the PoW (Proof of Work) for this block has been completed, it would create a fork on the network (since you now have multiple blocks pointing to a single preceding block). </p> <p>As Bitcoin uses the longest chain rule, any blocks outside of this chain (such as those in forks) would become stale and be rejected from the network. Introducing too many stale blocks would eventually degrade the security of the network. </p> <p>Essentially:</p> <p>More/Larger Blocks \u2192 Slower Block Propagation \u2192 More Forks \u2192 Less Security</p>"},{"location":"What_is_BlockDAG/#blockdag","title":"BlockDAG","text":"<p>BlockDAG is a DAG whereby the nodes represent the blocks and the edges represent references to its predecessor blocks. Unlike blockchain, where a single block is created within a certain time period, a blockDAG is able to create multiple blocks concurrently enabling greater TPS. Moreover, in a blockchain, a block can have only one single reference to its predecessor whereas in a DAG, a block can reference multiple predecessor blocks. This has the added effect of being able to determine which blocks were created honestly and which ones were created by a malicious adversary.</p> <p></p> <p>Fig 2. Example of a blockDAG</p> <p>At the end of the day, blockDAG is merely a way of representing blocks and does not address other pressing matters such as how to deal with double-spending or the overall ordering of the blocks. For this, Qitmeer has adopted a hybrid consensus protocol combining both the SPECTRE and the GHOSTDAG protocol to create what it calls the MeerDAG consensus **protocol. This in summary addresses the double spending issue as well as provide linear ordering of the blocks.</p> <p>A more detailed explanation on blockDAG and MeerDAG can be found here and here.</p>"},{"location":"deploy_private_amana_network/","title":"Deploy Private Amana Network","text":"<p>Amana is a POA network that uses the Clique consensus protocol. The instructions below will demonstrate how to create a private, local 3-node network. In practice, an Amana network would only require one node to operate the network.</p>"},{"location":"deploy_private_amana_network/#requirements","title":"Requirements","text":"<p><code>qng</code> Source Code - https://github.com/Qitmeer/qng</p> <p><code>go</code> - <code>1.19.x</code> or above (<code>1.20.x</code> is recommended)</p> <p><code>build-essential</code> (we\u2019ll assume you\u2019re using Ubuntu/Debian)</p>"},{"location":"deploy_private_amana_network/#clone-qng-repository","title":"Clone qng repository","text":"<p>Amana relies on the existing <code>qng</code> node and in our private network, also requires making certain modifications to the <code>qng/meerevm/amana/genesis.go</code> file before needing to be compiled. This requires cloning the repository from GitHub.</p> <pre><code>git clone https://github.com/Qitmeer/qng.git\n</code></pre>"},{"location":"deploy_private_amana_network/#create-directories","title":"Create Directories","text":"<p>We will separate each of the nodes by creating three separate directories: <code>node1</code>, <code>node2</code>, and <code>node3</code>.</p> <pre><code>mkdir node1 node2 node3\n</code></pre>"},{"location":"deploy_private_amana_network/#generate-private-keys-address","title":"Generate Private Keys + Address","text":"<p>Amana POA requires each node to hold its own 256-bit private key for that node to become a sealer on the network. This private key will be used to derive an Ethereum address that must be unlocked to seal blocks. We will use Python and the <code>secrets</code> module included in the Python Standard Library (although you can use alternative means to randomly derive these keys). To generate a private key using <code>secrets</code>:</p> <pre><code>Python 3.10.6 (main, May 29 2023, 11:10:38) [GCC 11.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; import secrets\n&gt;&gt;&gt; priv_key_1 = \"0x\" + secrets.token_hex(32)\n&gt;&gt;&gt; priv_key_1\n'0x8c31ac305c9455ee7fdf025bb69a58bc08ee72e78a6fef9ca53cb17975811959'\n&gt;&gt;&gt; priv_key_2 = \"0x\" + secrets.token_hex(32)\n&gt;&gt;&gt; priv_key_2\n'0x14abc2f5c4d55398985a9d44a7d0e0ad6e5d8743a3c3e25a79c930f69e12144c'\n&gt;&gt;&gt; priv_key_3 = \"0x\" + secrets.token_hex(32)\n&gt;&gt;&gt; priv_key_3\n'0x8cb9f7d90138c0825a76715e00b2e073fd65da71c43ae51c339fd0c1a7b12d51'\n</code></pre> <p>To retrieve the public address from each of the private keys, we can use the Python package <code>eth-account</code></p> <pre><code>Python 3.10.6 (main, May 29 2023, 11:10:38) [GCC 11.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from eth_account import Account\n&gt;&gt;&gt; address_1 = Account.from_key('0x8c31ac305c9455ee7fdf025bb69a58bc08ee72e78a6fef9ca53cb17975811959').address\n&gt;&gt;&gt; address_1\n'0x160d02d70A278De6dfB45a8854319a30D62E9f8E'\n&gt;&gt;&gt; address_2 = Account.from_key('0x14abc2f5c4d55398985a9d44a7d0e0ad6e5d8743a3c3e25a79c930f69e12144c').address\n&gt;&gt;&gt; address_2\n'0xE79544b2A7C0946b42f8e7Cc0bdD6371fa9AD285'\n&gt;&gt;&gt; address_3 = Account.from_key('0x8cb9f7d90138c0825a76715e00b2e073fd65da71c43ae51c339fd0c1a7b12d51').address\n&gt;&gt;&gt; address_3\n'0xedC4c57154bF81c28b4ba6263758DA2729897cE5'\n</code></pre>"},{"location":"deploy_private_amana_network/#generating-custom-extradata-and-alloc-field","title":"Generating custom extraData and alloc Field","text":"<p>When initialising the genesis block, a custom <code>extraData</code> field is needed in order to list the authorised signers on the network. The formula for the <code>extraData</code> section in the genesis block is as follows:</p> <p><code>extraData</code> = Vanity (32 Byte) + Addresses of Authorised Signers + Signature (64 Byte)</p> <p>In most cases, both vanity and signature are going to be set to all zeroes. </p> <p>A short Python script has been created to automate this process further:</p> <pre><code>from eth_account import Account\n\nvanity = \"0\" * 64   # 32 bytes\nsealer_addr_1 = Account.from_key(PRIV_KEY_1).address[2:]    # Truncate \"0x\"\nsealer_addr_2 = Account.from_key(PRIV_KEY_2).address[2:]\nsealer_addr_3 = Account.from_key(PRIV_KEY_3).address[2:]\n\nsig = \"0\" * 130     # 65 bytes\nextraData = \"0x\" + vanity + sealer_addr_1 + sealer_addr_2 + sealer_addr_3 + sig\n</code></pre> <p>Once the custom <code>extraData</code> field has been generated, you will need to modify the <code>qng/meerevm/amana/genesis.go</code> file:</p> <pre><code>package amana\n\nimport (\n    mparams \"github.com/Qitmeer/qng/meerevm/params\"\n    qparams \"github.com/Qitmeer/qng/params\"\n    qcommon \"github.com/ethereum/go-ethereum/common\"\n    \"github.com/ethereum/go-ethereum/common/hexutil\"\n    \"github.com/ethereum/go-ethereum/core\"\n    \"github.com/ethereum/go-ethereum/params\"\n    \"math/big\"\n)\n\nfunc AmanaGenesis() *core.Genesis {\n    return &amp;core.Genesis{\n        Config:     mparams.AmanaChainConfig,\n        Nonce:      0,\n        Number:     0,\n        ExtraData:  hexutil.MustDecode(\"0x000000000000000000000000000000000000000000000000000000000000000071bc4403af41634cda7c32600a8024d54e7f64990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        GasLimit:   0x47b760,\n        Difficulty: big.NewInt(1),\n        Alloc:      decodePrealloc(),\n        Timestamp:  uint64(qparams.MainNetParam.GenesisBlock.Block().Header.Timestamp.Unix()),\n    }\n}\n\nfunc AmanaTestnetGenesis() *core.Genesis {\n    return &amp;core.Genesis{\n        Config:     mparams.AmanaTestnetChainConfig,\n        Nonce:      1,\n        Number:     0,\n        ExtraData:  hexutil.MustDecode(\"0x000000000000000000000000000000000000000000000000000000000000000071bc4403af41634cda7c32600a8024d54e7f64990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        GasLimit:   0x47b760,\n        Difficulty: big.NewInt(1),\n        Alloc:      decodePrealloc(),\n        Timestamp:  uint64(qparams.TestNetParam.GenesisBlock.Block().Header.Timestamp.Unix()),\n    }\n}\n\nfunc AmanaMixnetGenesis() *core.Genesis {\n    return &amp;core.Genesis{\n        Config:     mparams.AmanaMixnetChainConfig,\n        Nonce:      0,\n        Number:     0,\n        ExtraData:  hexutil.MustDecode(\"0x000000000000000000000000000000000000000000000000000000000000000071bc4403af41634cda7c32600a8024d54e7f64990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        GasLimit:   0x47b760,\n        Difficulty: big.NewInt(1),\n        Alloc:      decodePrealloc(),\n        Timestamp:  uint64(qparams.MixNetParam.GenesisBlock.Block().Header.Timestamp.Unix()),\n    }\n}\n\nfunc AmanaPrivnetGenesis() *core.Genesis {\n    return &amp;core.Genesis{\n        Config:     mparams.AmanaPrivnetChainConfig,\n        Nonce:      0,\n        Number:     0,\n        // This section needs to be modified\n        ExtraData:  hexutil.MustDecode(\"0x0000000000000000000000000000000000000000000000000000000000000000160d02d70A278De6dfB45a8854319a30D62E9f8EE79544b2A7C0946b42f8e7Cc0bdD6371fa9AD285edC4c57154bF81c28b4ba6263758DA2729897cE50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"),\n        GasLimit:   0x47b760,\n        Difficulty: big.NewInt(1),\n        Alloc:      decodePrealloc(),\n        Timestamp:  uint64(qparams.PrivNetParam.GenesisBlock.Block().Header.Timestamp.Unix()),\n    }\n}\n\nfunc decodePrealloc() core.GenesisAlloc {\n    ga := core.GenesisAlloc{}\n    // ...and this too. The address and the amount allocated can be changed.\n    ga[qcommon.HexToAddress(\"0x160d02d70A278De6dfB45a8854319a30D62E9f8E\")] = core.GenesisAccount{Balance: big.NewInt(params.Ether).Mul(big.NewInt(params.Ether), big.NewInt(10000000000))}\n    ga[qcommon.HexToAddress(\"0xE79544b2A7C0946b42f8e7Cc0bdD6371fa9AD285\")] = core.GenesisAccount{Balance: big.NewInt(params.Ether).Mul(big.NewInt(params.Ether), big.NewInt(10000000000))}\n    ga[qcommon.HexToAddress(\"0xedC4c57154bF81c28b4ba6263758DA2729897cE5\")] = core.GenesisAccount{Balance: big.NewInt(params.Ether).Mul(big.NewInt(params.Ether), big.NewInt(10000000000))}\n    return ga\n}\n</code></pre> <p>In our example each of our sealers has <code>10000000000</code> Ether but this value and who recieves it can also be changed.</p>"},{"location":"deploy_private_amana_network/#compile-qng-binary","title":"Compile qng binary","text":"<p>Once <code>genesis.go</code> has been modified, you will need to compile the source code:</p> <pre><code># Enter the qng root directory\ncd ~/qng\nmake\n</code></pre> <p>If successful you should find a <code>qng</code> binary in the <code>qng/build/bin</code> directory. Copy this binary into the each of the node directories.</p> <pre><code>cp ~/qng/build/bin/qng node1\ncp ~/qng/build/bin/qng node2\ncp ~/qng/build/bin/qng node3\n</code></pre>"},{"location":"deploy_private_amana_network/#generate-node-files","title":"Generate Node Files","text":"<p>To generate the neccesary files for your Amana network, run the following command <code>./qng -A ./ --privnet --amana --cleanup</code>for each Amana node.</p> <pre><code>./qng -A ./ --privnet --amana --cleanup\n2023-09-30|06:17:18.417 [INFO ] System info                         QNG Version=1.0.24+dev-4ba0c35-dirty Go version=go1.20.5\n2023-09-30|06:17:18.417 [INFO ] System info                         Home dir=/home/xboxuser/test-amana/node1\n2023-09-30|06:17:18.417 [INFO ] Loading block database              dbPath=/home/xboxuser/test-amana/node1/data/privnet/blocks_ffldb\n2023-09-30|06:17:18.448 [INFO ] Block database loaded \n2023-09-30|06:17:18.448 [INFO ] Removing block database from '/home/xboxuser/test-amana/node1/data/privnet/blocks_ffldb' \n2023-09-30|06:17:18.449 [INFO ] Finished cleanup:/home/xboxuser/test-amana/node1/data/privnet/meereth module=MEER\n2023-09-30|06:17:18.449 [INFO ] Finished cleanup:/home/xboxuser/test-amana/node1/data/privnet/amana module=Amana\n2023-09-30|06:17:18.449 [INFO ] Finished cleanup \n2023-09-30|06:17:18.449 [INFO ] Gracefully shutting down the database... \n2023-09-30|06:17:18.449 [INFO ] Shutdown complete\n</code></pre> <p>You should see two further directories created: <code>data</code> and <code>logs</code>. </p>"},{"location":"deploy_private_amana_network/#create-keystore","title":"Create Keystore","text":"<p>This private key must be encrypted (with a password as the encryption key) and stored in each node directory as a JSON keystore directory. We can use  <code>eth-account</code> to encrypt the private key using password \u201camana1\u201d with the output saved onto a JSON file. </p> <pre><code># First create the keystore directories for each node\nmkdir $NODE_1_DIRECTORY/data/privnet/keystore\nmkdir $NODE_2_DIRECTORY/data/privnet/keystore\nmkdir $NODE_3_DIRECTORY/data/privnet/keystore\n</code></pre> <p>We will use a Python script to automate the process of creating the keystore file, and generating the <code>password.txt</code> for each of the nodes.</p> <pre><code>from eth_account import Account\nimport subprocess\n\nwith open(NODE_1_DIRECTORY + \"/data/privnet/keystore/keystore_1.json\", \"w\") as node1_file:\n        # Encrypt our private key using the passphrase \"amana1\"\n      node_1_json = json.dumps(Account.encrypt(PRIV_KEY_1, \"amana1\"), indent=4)\n      node1_file.write(node_1_json)\n\nwith open(NODE_2_DIRECTORY + \"/data/privnet/keystore/keystore_2.json\", \"w\") as node2_file:\n        node_2_json = json.dumps(Account.encrypt(PRIV_KEY_2, \"amana1\"), indent=4)\n    node2_file.write(node_2_json)\n\nwith open(NODE_3_DIRECTORY + \"/data/privnet/keystore/keystore_3.json\", \"w\") as node3_file:\n    node_3_json = json.dumps(Account.encrypt(PRIV_KEY_3, \"amana1\"), indent=4)\n    node3_file.write(node_3_json)\n\n# Password files to unlock accounts\nsubprocess.Popen(\"cp password.txt \" + NODE_1_DIRECTORY, shell=True).wait()\nsubprocess.Popen(\"cp password.txt \" + NODE_2_DIRECTORY, shell=True).wait()\nsubprocess.Popen(\"cp password.txt \" + NODE_3_DIRECTORY, shell=True).wait()\n</code></pre>"},{"location":"deploy_private_amana_network/#generate-config-file","title":"Generate Config file","text":"<p>Each node would need an configuration file with some changes needing to be made (usually port numbers if nodes are ran locally). Config files are in the TOML format.</p> <p>Example config file:</p> <pre><code>privnet=true\namana=true\namanaenv=\"--unlock 0x160d02d70A278De6dfB45a8854319a30D62E9f8E --port 37000 --password password.txt --http --http.api=eth,net,web3,amana --http.corsdomain=* --http.port 8545 --allow-insecure-unlock miner.etherbase 0x160d02d70A278De6dfB45a8854319a30D62E9f8E --mine\"\n</code></pre>"},{"location":"deploy_private_amana_network/#running-amana-node","title":"Running Amana Node","text":"<p>To start the Amana node, run the command: <code>./qng -A ./ -C config.toml</code></p> <p>(<code>config.toml</code> is what we have named our configuration file).</p> <pre><code>./qng -A ./ -C config.toml\n2023-09-30|06:40:14.734 [INFO ] System info                         QNG Version=1.0.24+dev-4ba0c35-dirty Go version=go1.20.5\n2023-09-30|06:40:14.737 [INFO ] System info                         Home dir=./\n2023-09-30|06:40:14.737 [INFO ] Loading block database              dbPath=/home/xboxuser/qng_privnet/node2/data/privnet/blocks_ffldb\n2023-09-30|06:40:14.810 [INFO ] Block database loaded \n2023-09-30|06:40:14.816 [INFO ] transaction index is enabled        module=INDEX\n2023-09-30|06:40:14.827 [INFO ] anticone size:4                     module=DAG\n2023-09-30|06:40:14.830 [INFO ] System info                         module=EVM   ETH VM Version=meervm-v0.0.2 Go version=go1.20.5\n2023-09-30|06:40:15.065 [INFO ] New local node record               seq=1696052415063 id=8642152b221a63ca ip=127.0.0.1 udp=8538 tcp=0\n2023-09-30|06:40:15.107 [INFO ] Prepare meereth on NetWork(8133)... \n2023-09-30|06:40:15.113 [INFO ] Maximum peer count                  ETH=0 LES=0 total=0\n2023-09-30|06:40:15.120 [INFO ] Smartcard socket not found, disabling err=\"stat /run/pcscd/pcscd.comm: no such file or directory\"\n2023-09-30|06:40:15.141 [WARN ] Sanitizing cache to Go's GC limits  provided=4096 updated=1303\n2023-09-30|06:40:15.145 [INFO ] Set global gas cap                  cap=50000000\n2023-09-30|06:40:15.150 [INFO ] Allocated trie memory caches        clean=195.00MiB dirty=325.00MiB\n2023-09-30|06:40:15.154 [INFO ] Using leveldb as the backing database \n2023-09-30|06:40:15.155 [INFO ] Allocated cache and file handles    database=/home/xboxuser/qng_privnet/node2/data/privnet/meereth/chaindata cache=649.00MiB handles=524288\n2023-09-30|06:40:15.232 [INFO ] Using LevelDB as the backing database \n2023-09-30|06:40:15.284 [INFO ] Opened ancient database             database=/home/xboxuser/qng_privnet/node2/data/privnet/meereth/chaindata/ancient/chain readonly=false\n2023-09-30|06:40:15.340 [INFO ] Disk storage enabled for MeerEngine caches dir=/home/xboxuser/qng_privnet/node2/data/privnet/meereth/ethash count=3\n2023-09-30|06:40:15.341 [INFO ] Disk storage enabled for MeerEngine DAGs dir=/home/xboxuser/qng_privnet/node2/data/privnet/meereth/ethash/dataset count=2\n2023-09-30|06:40:15.345 [INFO ] Initialising Ethereum protocol      network=8133 dbversion=8\n2023-09-30|06:40:16.144 [INFO ]  \n2023-09-30|06:40:16.155 [INFO ] --------------------------------------------------------------------------------------------------------------------------------------------------------- \n2023-09-30|06:40:16.155 [INFO ] Chain ID:  8133 (qng-priv)\n...\n\n.__  __                                                                    \n    _____|__|/  |_  _____   ____   ___________    QNG 1.0.24+dev-4ba0c35-dirty\n   / ____/  \\   __\\/     \\_/ __ \\_/ __ \\_  __ \\   Port: 38130\n  &lt; &lt;_|  |  ||  | |  Y Y  \\  ___/\\  ___/|  | \\/   PID : 266551\n   \\__   |__||__| |__|_|  /\\___  &gt;\\___  &gt;__|      Network : privnet                      \n      |__|              \\/     \\/     \\/          https://github.com/Qitmeer/qng\n</code></pre>"},{"location":"deploy_private_amana_network/#running-proxy","title":"Running Proxy","text":"<p>To run the proxy enter the command: <code>python3 [proxy.py](http://proxy.py)</code></p> <pre><code>python3 proxy.py\n* Serving Flask app 'proxy'\n * Debug mode: off\nWARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.\n * Running on http://localhost:5000\nPress CTRL+C to quit\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"OPTIONS / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"eth_getBlockByNumber\",\"params\":[\"latest\",false],\"id\":42,\"jsonrpc\":\"2.0\"}\n{\"method\":\"eth_chainId\",\"params\":[],\"id\":43,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"POST / HTTP/1.1\" 200 -\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"POST / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"net_version\",\"params\":[],\"id\":44,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"POST / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:54] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"net_version\",\"params\":[],\"id\":45,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"POST / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"eth_accounts\",\"params\":[],\"id\":46,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"POST / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"eth_getBalance\",\"params\":[\"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\",\"latest\"],\"id\":47,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"POST / HTTP/1.1\" 200 -\n127.0.0.1 - - [30/Sep/2023 06:49:55] \"OPTIONS / HTTP/1.1\" 200 -\n{\"method\":\"eth_getBalance\",\"params\":[\"0x70997970c51812dc3a010c7d01b50e0d17dc79c8\",\"latest\"],\"id\":48,\"jsonrpc\":\"2.0\"}\n&lt;Response [200]&gt;\n</code></pre> <p>The verbose output is the result of connecting the proxy to Remix IDE which sends multiple JSON-RPC requests very frequently. </p>"},{"location":"deploy_private_amana_network/#deploy-acl-smart-contract-to-amana","title":"Deploy ACL Smart Contract to Amana","text":"<p>Because Amana is EVM compatible, the steps needed to deploy a smart contract is very similar to other EVM compatible networks. We can use <code>Hardhat</code> and the <code>ethers.js</code> library to create a JS script to automate the deployment. The script would also insert an address(in this case <code>0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266</code>) to be put into the whitelist.</p> <pre><code>// deploy.js \nconst fs = require('fs');\n\nasync function main() {\n    const [deployer] = await ethers.getSigners();\n\n    console.log(\"Deploying contracts with the account:\", deployer.address);\n    const permission = await ethers.deployContract(\"Permission\");\n\n    const address = await permission.getAddress();\n    console.log(\"Contract Address:\", address);\n\n    const content = \"ADDRESS=\"+ address;\n\n    try {\n        fs.writeFileSync(\".env\", content);\n        // file written successfully\n    } catch (err) {\n        console.error(err);\n    }\n\n    // Insert test data\n   let tx = await permission.addToWhitelist(\"0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\");\n    await tx.wait()\n\n  }\n\n  main()\n    .then(() =&gt; process.exit(0))\n    .catch((error) =&gt; {\n      console.error(error);\n      process.exit(1);\n    });\n</code></pre>"},{"location":"meerEVM_deploying_SmartContracts/","title":"QNG - EVM &amp; Deploying Smart Contracts","text":""},{"location":"meerEVM_deploying_SmartContracts/#qng-setting-up-node","title":"QNG - setting up node","text":"<p>To interact with the QNG (testnet), you would need to configure your Qitmeer node by including both the <code>--testnet</code> and <code>--evmenv</code> flag and specifying the necessary parameters before starting the node.</p> <p>Interacting with QNG requires the client sending a series of JSON-RPC API methods to the node which can only be done by enabling a server on the node to accept JSON-RPC requests. </p> <p>Currently you can use the API via RPC through these protocols: - HTTP - WebSocket</p>"},{"location":"meerEVM_deploying_SmartContracts/#http","title":"HTTP","text":"<p>To enable the HTTP server, you would need to insert the <code>--http</code> parameter inside of <code>--evmenv</code> flag: </p> <pre><code>&gt; ./qng --testnet --evmenv=\"--http\"\n</code></pre> <p>By default, the port number should be set to 18535 but this can be altered by modifying <code>--http.port=&lt;port-number&gt;</code>. For example, if you want to set the port number to 12345, then you would need to input the command: <code>./qng --testnet --evmenv=\"--http --http.port=1234\"</code></p> <p>You can also specify the JSON-RPC API that you would like to use through the <code>--http.api</code> parameter: </p> <pre><code>&gt; ./qng --testnet --evmenv=\"--http --http.api=eth,net,rpc,web3,personal,debug\"\n</code></pre> <p>By default, only <code>eth</code>, <code>net</code>, <code>rpc</code> and <code>web3</code> API methods are provided if <code>--http.api</code> is not explicitly specified</p>"},{"location":"meerEVM_deploying_SmartContracts/#websocket","title":"WebSocket","text":"<p>To enable the WebSockets, you would need to insert the <code>--ws</code> parameter inside of <code>--evmenv</code> flag:</p> <pre><code>&gt; ./qng --testnet --evmenv=\"--ws\"\n</code></pre> <p>Again, similar to HTTP, the port number by default is set to 18536. This can be altered by <code>--ws.port=&lt;port-number&gt;</code>. For example, if you want to set the port number to 12345, then you would need to input the command: <code>./qng --testnet --evmenv=\"--ws --ws.port=12345\"</code></p>"},{"location":"meerEVM_deploying_SmartContracts/#clish","title":"cli.sh","text":"<p>cli.sh is a bash script that will allow you to run JSON-RPC methods on the Qitmeer UTXO network (not QNG).</p> <p>Before the running the script you must set the corresponding variables to match the settings of the Qitmeer UTXO RPC server running on the node:</p> <ul> <li><code>$host</code> - IP address of host (default: 127.0.0.1)</li> <li><code>$port</code> - port number (default: 1234)</li> <li><code>$user</code> - username for RPC server (default: \"test\") </li> <li><code>$pass</code> - password for RPC server (default: \"test\")</li> </ul> <p>The port number for the Qitmeer RPC server is by default, set to 18131 unless changed otherwise. </p> <p>Again, the configuration settings must match the RPC server for the Qitmeer network and not QNG or what has been entered in the <code>--evmenv</code> flag.</p> <p>If the default values do not correspond to those set on the node, then, they must be changed. You can alter the settings by issuing the following command:</p> <pre><code>export host=&lt;host-IP&gt; port=&lt;port-number&gt; user=&lt;username&gt; pass=&lt;password&gt;\n</code></pre> <p>It may be easier for you to simply change the default values on the script if your not going to change the values often. That way you don't have to worry about your environment variables being accurately set.</p> <p>This could be done by modifying this portion of the script : </p> <pre><code>// cli.sh - line 641\n\nfunction get_result(){\n  local proto=\"https\"\n  if [ $notls -eq 1 ]; then\n     proto=\"http\"\n  fi\n  if [ -z \"$host\" ]; then\n     host=127.0.0.1\n  fi\n  if [ -z \"$port\" ]; then\n     port=1234\n  fi\n  if [ -z \"$user\" ]; then\n     user=\"test\"\n  fi\n  if [ -z \"$pass\" ]; then\n     pass=\"test\"\n  fi\n</code></pre>"},{"location":"meerEVM_deploying_SmartContracts/#cross-chain-exchange-qitmeer-qng","title":"Cross-chain Exchange (Qitmeer -&gt; QNG)","text":"<p>It is possible to exchange your MEER coins from the Qitmeer UTXO network to QNG.</p>"},{"location":"meerEVM_deploying_SmartContracts/#method-1-using-kahf-wallet","title":"Method 1: Using KAHF Wallet","text":"<p>You can use the KAHF wallet app to easily transfer MEER from Qitmeer UTXO to QNG</p> <ol> <li>On the home page, click on the last icon labelled \"Transfer\"</li> </ol> <p></p> <ol> <li> <p>Select the address you would like to send it to and enter the amount.</p> </li> <li> <p>Click \"Confirm\" and enter your password or fingerprint (if this has been set up).</p> </li> <li> <p>You should see the transaction details on the screen. Click on \"Transfer\" to finalise the transaction.</p> </li> </ol> <p></p>"},{"location":"meerEVM_deploying_SmartContracts/#add-qng-to-metamask","title":"Add QNG to Metamask","text":"<p>You must have the Metamask browser extension installed before proceeding ahead. </p>"},{"location":"meerEVM_deploying_SmartContracts/#method-1-use-public-rpc-node-easier-option","title":"Method 1: use public RPC node (easier option)","text":"<p>You can take advantage of a public RPC endpoint to deploy your smart contracts, rather than host the infrastructure yourself. </p> <p>The first thing to do is to add the QNG network to your Metamask wallet.</p> <p>Click on the Metamask browser extension icon and click on the circular icon on the top right:</p> <p></p> <p>Next click on Settings &gt; Networks &gt; Add Network</p> <p>Add the following information to allow the wallet to connect to the RPC endpoint: </p> <ul> <li>Network Name: QNG - Testnet </li> <li>New RPC URL: https://explorer.qitmeer.io/rpc</li> <li>Chain ID: 223</li> <li>Currency Symbol: MEER</li> <li>Block Explorer URL: https://qng-testnet.meerscan.io/</li> </ul> <p>It should look something like this:</p> <p></p> <p>Finally, click on the \"Save\" button. Metamask will attempt to connect to the endpoint. If you do not encounter any errors then the process has been a success.</p>"},{"location":"meerEVM_deploying_SmartContracts/#method-2-use-own-rpc-node","title":"Method 2: use own RPC node","text":"<p>If you would prefer to use your own node, you can configure Metamask to connect to your RPC endpoint using the same method mentioned above. </p> <ol> <li>The first step is to have the node running with the <code>--evmenv</code> flag enabled with the necessary parameters: <code>./qng --testnet --evmenv=\"--http --http.port=18545 --http.corsdomain=chrome-extension://nkbihfbeogaeaoehlefnkodbefgpgknn\"</code></li> </ol> <p><code>--http.corsdomain</code> must be enabled, with the value equal to the URL of the client that wants to connect to our node. Although you can set the value to \"\" to allow anybody to connect to the node, this is generally bad practice and should only be done inside of a test environment or if you know what you are doing*!</p> <p>To find the value of <code>--http.corsdomain</code>, click on the Metamask icon and click on account options:</p> <p></p> <p>Click on \"Expand View\" and copy the URL of the address bar. You should see it starting with <code>chrome-extension://</code> or <code>moz-extension://</code> and copy the URL but removing the <code>/home.html</code> part</p> <p></p> <ol> <li> <p>Add the network to the Metamask wallet using the previous method outlined above. Only the \"New RPC URL\" value should be changed with the remaining parameters being the same as above.</p> </li> <li> <p>Click on the \"Save\" button. Metamask will attempt to connect to the endpoint. If you do not encounter any errors then the process has been a success. </p> </li> </ol>"},{"location":"meerEVM_deploying_SmartContracts/#deploy-smart-contract-on-qng","title":"Deploy Smart Contract on QNG","text":"<p>In this section we will attempt to deploy a \"Hello World\" smart contract on QNG. In this example we will be using Remix IDE although you can use any library or development environment (such as Hardhat, Truffle etc.) to complete this task.</p> <p>The contract we will attempt to deploy is: <pre><code>// Available at https://blog.chain.link/how-to-create-a-hello-world-smart-contract-with-solidity/\n// SPDX-License-Identifier: MIT\n\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n\ncontract HelloWorld {\n    function sayHelloWorld() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}\n</code></pre></p>"},{"location":"meerEVM_deploying_SmartContracts/#connect-metamask-to-remix-ide","title":"Connect Metamask to Remix IDE","text":"<ol> <li>Select the right network for your Metamask wallet. This should be \"QNG - Testnet\" (or whatever you decided to call it)</li> </ol> <ol> <li>Next visit the Remix IDE website and click on the \"Deploy and run transactions icon\"</li> </ol> <ol> <li>Click on the \"Environment\" tab and select \"Injected Provider - Metamask\". You should recieve a pop-up from Metmask asking whether you would like to connect your wallet. You should click accept. If it was successful, you should not see any errors.</li> </ol> <ol> <li>Click on the \"File Explorer\" tab, click on \"Create new file\" and name it <code>hello-world.sol</code> and copy and paste the following code: <pre><code>// Available at https://blog.chain.link/how-to-create-a-hello-world-smart-contract-with-solidity/\n// SPDX-License-Identifier: MIT\n\npragma solidity &gt;=0.7.0 &lt;0.9.0;\n\ncontract HelloWorld {\n    function sayHelloWorld() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}\n</code></pre></li> </ol> <ol> <li>Press CTRL + S to compile your contract. You should see a tick if the contract was compiled successfully. </li> </ol> <ol> <li>Click on the \"Deploy and run transactions tab\" and select the \"hello-world.sol\" smart contract. Click \"deploy\" to deploy onto QNG. You should get a prompt by Metamask asking whether you would like to confirm the transaction. Click \"accept\". </li> </ol> <p>We can view our transaction on the QNG Testnet Explorer: https://testnet.qng.meerscan.io/tx/0xbf52631a396aaac1f90c58ee721e5c0c09882564ab2f2e3c52444804780695ca</p> <p></p> <ol> <li>Contracts that have been deployed will appear in the \"Deployed Contracts\" section. Click on the \"sayHelloWorld\" button to call the function. The output should appear below as <code>0:string:Hello World</code></li> </ol> <p></p> <p>As <code>sayHelloWorld()</code> is a pure function, in this instance, a transaction will not be created unlike the contract creation process.</p>"},{"location":"solidity_tutorial_basics_part_1/","title":"Solidity Tutorial - Basics (Part 1)","text":"<p>Solidity is an object-oriented, high-level language for implementing smart contracts. It is influenced by other high level languages such as C++, Python and JavaScript for writing smart contracts specifically for the EVM (Ethereum Virtual Machine). Whilst smart contracts can be written in various different languages, Solidity continues to remain the most popular amongst blockchain developers (as of writing of course).  </p> <p>In these series of tutorials, we will be covering certain key concepts, so that by the end, you will be able to create your very own smart contract \ud83d\ude42</p>"},{"location":"solidity_tutorial_basics_part_1/#spdx-license-identifier","title":"SPDX License Identifier","text":"<p>On the top of some smart contracts, you may find something like this: </p> <pre><code>// SPDX-License-Identifier: MIT\n</code></pre> <p>This line is simply a machine-readable SPDX license identifier that indicates which license you would like your source code to fall under. In the example above, the smart contract will use the MIT  license. Having a license identifier is not mandatory and you will be able to compile your smart contracts just fine without it. It will be important if you do wish to open-source your code so that others can modify and redistribute your code. </p> <p>If you don\u2019t wish to use the MIT license, the full SPDX license list can be found here.</p>"},{"location":"solidity_tutorial_basics_part_1/#pragmas","title":"Pragmas","text":"<p>After including your license, the next thing you may come across is something like this:</p> <pre><code>pragma solidity &gt;=0.8.2 &lt;0.9.0;\n</code></pre> <p>Pragmas are used in Solidity to enable certain compiler features and checks. One of the most common is the version pragma (as shown above) which checks that the version of the Solidity compiler matches the version explicitly stated in the smart contract. You can specify a single, fixed version number or a specific range using comparison operators.</p> <p>Version pragma is important as each <code>0.x.0</code> introduces breaking changes that may make your smart contract incompatible with the previous version. The version pragma is not mandatory but it will certainly help eliminate a lot of compilation errors and bugs if you knew which version the smart contract was compiled under!   </p>"},{"location":"solidity_tutorial_basics_part_1/#imports","title":"Imports","text":"<p>Like with any other code you would write, you may need to import other files/libraries into your current code. With Solidity, you can import both local and external files using the <code>import</code> keyword.</p>"},{"location":"solidity_tutorial_basics_part_1/#local","title":"Local","text":"<p>If you have two files Foo.sol and Import.sol in a file structure like this:</p> <pre><code>\u251c\u2500\u2500 Import.sol\n\u2514\u2500\u2500 Foo.sol\n</code></pre> <p>You can import Foo.sol into Import.sol by specifying its relative path:</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n// import Foo.sol from current directory\nimport \"./Foo.sol\";\n</code></pre>"},{"location":"solidity_tutorial_basics_part_1/#external","title":"External","text":"<p>You can also import from external sources such as from GitHub, NPM and IPFS:</p> <pre><code>// Import from GithHub URL\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.0/contracts/math/SafeMath.sol\";\n\n// Import from NPM\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n// Import from IPFS\nimport 'ipfs://Qmdyq9ZmWcaryd1mgGZ4PttRNctLGUSAMpPqufsk6uRMKh';\n</code></pre>"},{"location":"solidity_tutorial_basics_part_1/#comments","title":"Comments","text":"<p>Solidity allows for single and multi-line comments. Single line comments are denoted with <code>//</code> and multi-line comments are denoted with <code>/*...*/</code></p> <pre><code>// This is a single-line comment.\n\n/*\nThis is a\nmulti-line comment.\n*/\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/","title":"Solidity Tutorial - Basics (Part 2)","text":"<p>In this section, we\u2019ll be delving deeper into Solidity and covering further concepts such as: variables (add more here)</p>"},{"location":"solidity_tutorial_basics_part_2/#variables","title":"Variables","text":"<p>Solidity is a statically typed language meaning that the type of the variable must be explicitly declared before a value can be assigned to it. For instance, if you wanted to store a 256-bit integer into variable <code>a</code>, you would write:</p> <pre><code>// Declare an integer\nint a;\na = 20;\n\n// or like this\nint a = 20;\n\n// or since int and int256 are aliases, you could write:\nint256 a = 20;\n</code></pre> <p>In Solidity variables can be categorised into one of two types:</p> <ul> <li>Value Types</li> <li>Reference Types</li> </ul>"},{"location":"solidity_tutorial_basics_part_2/#value-types","title":"Value Types","text":"<p>Value types basic data types whose variables are passed by value when used in function arguments or assignments. This means that when they are assigned or passed as arguments, a copy of the value is created</p> <p>These types include:</p> <ul> <li>Boolean</li> <li>Signed/Unsigned Integer</li> <li>Fixed Point Numbers (although not fully supported by Solidity yet)</li> <li>Address (Ethereum)</li> <li>Fixed-size Bytes</li> <li>Enum</li> </ul> <pre><code>// Integer\nint myInt = -20;\n\n// Unsigned Integer\nuint myUint = 30;\n\n//Boolean\nbool myBool = true;\n\n// Etheruem Address\naddress myAddress = 0x751bc4cd7E77033fBDb9206fF306549d6dD017f8;\n\n// Bytes (can be between bytes1..32)\nbytes32 myBytes = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n\n// Enums (return uint depending on index)\nenum Button {\n    OFF,\n    PENDING,\n    ON\n}\n\n/*\nReturns uint8 depending on the index of which element was selected\nOFF - 0\nON - 1\n*/\n\n// This would return a uint with value 0\nButton myButton = Button.OFF;\n\n// This would return a uint with value 1\nButton myButton = Button.PENDING\n\n// This would return a uint with value 2\nButton myButton = Button.ON\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#reference-types","title":"Reference Types","text":"<p>Reference types are types that store a reference to the memory location where the data is stored, rather than the data itself. When a reference type is assigned or passed as an argument, only the reference to the memory location is copied, not the actual data.</p> <p>These types include:</p> <ul> <li>Array</li> <li>String</li> <li>Struct</li> <li>Mapping</li> </ul>"},{"location":"solidity_tutorial_basics_part_2/#fixed-arrays","title":"Fixed Arrays","text":"<p>Fixed arrays are arrays that store a fixed size collection of elements of the same type.</p> <pre><code>// Declare a fixed array of unsigned integers\nuint[5] fixArray = [10,20,30,40,50];\n\nfunction retrieveElementArray(uint index) public view returns (uint) {\n    return fixArray[index];\n}\n\nfunction retrieveFullArray() public view returns (uint[5] memory) {\n    return fixArray;\n}\n\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 20\nretrieveElementArray(4) =&gt; uint256 : 50\n\nSelecting an index outside the stated range will produce an error and revert the EVM to the intial state\nretrieveElementArray(10) =&gt; error\n\nretrieveFullArray() =&gt; uint256[5] : [10,20,30,40,50]\n*/\n</code></pre> <p><code>uint</code> and <code>uint256</code> are exact aliases and behave exactly the same.</p> <p>In a fixed array, any element not assigned will be set to its default value depending on its type:</p> <pre><code>// Declare a fixed array of unsigned integers\nuint[5] fixArray = [10,30,40,50];\n\nfunction retrieveElementArray(uint index) public view returns (uint) {\n    return fixArray[index];\n}\n\nfunction retrieveFullArray() public view returns (uint[5] memory) {\n    return fixArray;\n}\n\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 30\n\nAs this element hasn't beeen assigned, it will be set to 0 (this is the default value for type uint256)\nretrieveElementArray(4) =&gt; uint256 : 0\n\nretrieveFullArray() =&gt; uint256[5] : [10,30,40,50,0]\n*/\n</code></pre> <p>We can also create temporary arrays stored in memory inside of functions. Unlike arrays in storage, the elements of these arrays would be removed after the execution of the function. </p> <pre><code>function createFixArray() public pure returns (uint[5] memory) {\n    uint[5] memory fixArray;\n    fixArray[0] = 10;\n    fixArray[1] = 20;\n    fixArray[2] = 30;\n\n    return fixArray;\n}\n</code></pre> <pre><code>// This won't work\nfunction createFixArray() public pure returns (uint[5] memory) {\n    uint[5] memory fixArray;\n    fixArray = [10,20,30,40,50]; // &lt;= TypeError: Type uint8[5] memory is not implicitly convertible to expected type uint256[5] memory\n\n    return fixArray;\n}\n</code></pre> <pre><code>//But this will - array needs to be converted to type uint8\nfunction createFixArray() public pure returns (uint8[5] memory) {\n    uint8[5] memory fixArray;\n    fixArray = [10,20,30,40,50];\n\n    return fixArray;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#dynamic-arrays","title":"Dynamic Arrays","text":"<p>Dynamic arrays unlike fixed sized arrays, can be used to store an arbitrary number of elements of the same type.</p> <pre><code>// Declare a dynamic array of unsigned integers\nuint[] dynArray = [10,20,30,40,50];\n\nfunction retrieveElementDynArray(uint index) public view returns (uint) {\n    return dynArray[index];\n}\n\nfunction retrieveFullDynArray() public view returns (uint[] memory) {\n    return dynArray;\n}\n\n// Find the length of the dynamic array\nfunction getLengthArray() public view returns (uint) {\n    return dynArray.length;\n}\n\n// Append to array. This will increase the array length by 1.\nfunction appendArray(uint i) public {\n    dynArray.push(i);\n}\n\n// Remove last element from array. This will decrease the array length by 1\nfunction popArray() public {\n    dynArray.pop();\n}\n\n// Delete does not change the array length. It resets the value at index to it's default value which in this case is 0\nfunction removeArray(uint index) public {\n    delete dynArray[index];\n}\n\n/*\nretrieveElementArray(0) =&gt; uint256 : 10\nretrieveElementArray(1) =&gt; uint256 : 20\nretrieveElementArray(4) =&gt; uint256 : 50\n\nretrieveFullDynArray() =&gt; uint256[] : [10,20,30,40,50]\n\ngetLengthArray() =&gt; uint256: 5\n\nappendArray(80) =&gt; no return value\ndynArray = [10,20,30,40,50,80]\n\npopArray() =&gt; no return value\ndynArray = [10,20,30,40]\n\nremoveArray(2) =&gt; no return value\ndynArray = [10,20,0,40,50]\n\n*/\n</code></pre> <p>Dynamic arrays can only be created in storage. However, we can still create dynamically-allocated fixed arrays. </p> <pre><code>// User calling function can determine size of array using the \"len\" parameter\nfunction createArray(uint len) public pure returns (uint[] memory) {\n\n    // this will still behave like a fixed array so will not inherit dynamic array functions\n    uint[] memory arr = new uint[](len);\n    return arr;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#bytes","title":"Bytes","text":"<p><code>bytes</code> and <code>strings</code> are treated as special arrays that can store an arbitrary length of data. <code>string</code> is equal to <code>bytes</code> but does not allow length or index access. </p> <p>According to the Solidity docs:</p> <p>As a general rule, use <code>bytes</code> for arbitrary-length raw byte data and <code>string</code> for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types <code>bytes1</code> to <code>bytes32</code> because they are much cheaper.</p> <pre><code>bytes message = \"Hello World!\";\n\nfunction retrieveBytes() public view returns (bytes memory) {\n    return message;\n}\n\n// retrieveBytes() =&gt; bytes : 0x48656c6c6f20576f726c6421 ('Hello World!' in ASCII hexadecimal) \n</code></pre> <p>We can store bytes temporarily inside functions too:</p> <pre><code>function storeTempBytes() public pure returns (bytes memory) {\n    bytes memory message = \"Hello World!\";\n    return message;\n}\n\n// storeTempBytes() =&gt; bytes : 0x48656c6c6f20576f726c6421 ('Hello World!' in ASCII hexadecimal) \n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#strings","title":"Strings","text":"<p>Strings operate in a similar way as with bytes. However unlike bytes, the output would be in ASCII rather than in hexadecimal.</p> <pre><code>string message = \"Hello World!\";\n\nfunction retrieveString() public view returns (string memory) {\n    return message;\n}\n\n// retrieveString() =&gt; string : Hello World!\n</code></pre> <p>We can store strings temporarily inside functions too:</p> <pre><code>function storeTempString() public pure returns (string memory) {\n    string memory message = \"Hello World!\";\n    return message;\n}\n\n// storeTempString() =&gt; string : Hello World!\n</code></pre> <p>Both the <code>bytes</code> and <code>string</code> type have a built-in <code>concat</code> function that can be used to concatenate bytes and strings together:</p> <pre><code>// We can continue to use the 'memory' keyword but 'calldata' uses less gas\n\n// Function arguments do not need to be of type 'bytes' and can be value type bytes1..32\nfunction concatBytes(bytes calldata b1, bytes calldata b2) public pure returns (bytes memory) {\n    bytes memory b3 = bytes.concat(b1, b2);\n    return b3;\n}\n\n/*\nEnsure bytes in function arguments are of even length e.g 0xAB or 0xABCD (0xABC would not be permitted)\nconcatBytes(0xab, 0xcd) =&gt; bytes : 0xabcd\n*/\n\nfunction concatString(string calldata s1, string calldata s2) public pure returns (string memory) {\n    string memory s3 = string.concat(s1, s2);\n    return s3;\n}\n\n/*\nconcatString(\"Hello\", \"World!\") =&gt; string : Hello World!\n*/ \n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#mappings","title":"Mappings","text":"<p>Mappings in Solidity are hash tables that operate similar to a dictionary in other programming languages (e.g. Python)</p> <pre><code>// Intialise the mapping\nmapping (address =&gt; uint) values;\n\n// msg.sender is a global variable which is set to the address of the function caller\n// In this example the user can set a value that will be linked to their address  \n\nfunction setValue(uint amount) public {\n    values[msg.sender] = amount;\n}\n\nfunction checkValue() public view returns (uint) {\n    return values[msg.sender];\n}\n\n/*\nsetValue(100) =&gt; no return value (but the address has a value of 100 now)\n\ncheckValue() =&gt; 100 (only if same address was also used for the setValue function above)\n\n*/ \n</code></pre>"},{"location":"solidity_tutorial_basics_part_2/#structs","title":"Structs","text":"<p>Structs are used to define new types and group together related data and variables.</p> <pre><code>// In this example we will create the struct \"Car\" and group different variables\nstruct Car {\n    string make;\n    string colour;\n    uint price;\n    bool isPetrol;\n}\n</code></pre> <p>We can also create an array of type <code>Car</code> to store our structs:</p> <pre><code>struct Car {\n    string make;\n    string colour;\n    uint price;\n    bool isPetrol;\n}\n\n// initialise our Car array here\nCar[] cars;\n\n// lets create a function to create a Car struct and store it in our Car array\nfunction createCar(string calldata _make, string calldata _colour, uint _price, bool _isPetrol) public { \n    Car memory c  = Car(_make, _colour, _price, _isPetrol);\n    cars.push(c);\n}\n\n// we need to return type 'Car' just like other variable types\nfunction retrieveCar(uint index) public view returns (Car memory) {\n    return cars[index];\n}\n\n/*\ncreateCar(\"Ford\", \"Red\", 1000, false) =&gt; no return value (but new struct has been created)\n\n0 would be the index for the first entry\nretrieveCar(0) =&gt; tuple(string,string,uint256,bool): Ford,Red,1000,false\n*/\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/","title":"Solidity Tutorial - Basics (Part 3)","text":"<p>In the previous tutorial, we looked at the different types of variables and how to assign them. In this section we will look into an essential component in smart contracts (and generally most programming languages) - Functions.</p>"},{"location":"solidity_tutorial_basics_part_3/#functions","title":"Functions","text":"<p>Functions are reusable bits of code that can be called multiple times. In Solidity, they can be declared using the <code>function</code> keyword and the following syntax:</p> <pre><code>function &lt;function-name&gt;(&lt;list of parameters and type&gt;) &lt;visibility&gt; &lt;mutability&gt; &lt;modifier&gt; returns (&lt;type of return value&gt;) {\n&lt;embed logic here&gt;\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#function-visibility","title":"Function Visibility","text":"<p>When creating functions, you need to specify who can directly call functions inside of that smart contract by including its function visibility.</p> <p>There are 4 types of visibility:</p> <ul> <li><code>public</code></li> <li><code>private</code></li> <li><code>internal</code></li> <li><code>external</code></li> </ul>"},{"location":"solidity_tutorial_basics_part_3/#public","title":"Public","text":"<p>As the name suggests, public functions with the <code>public</code> keyword will be accessible to all users and contracts. State variables can also be assigned the <code>public</code> keyword, and the compiler will automatically create a getter function.</p> <pre><code>contract Parent {\n\n// We can make a state variable public and can access it using the getter function created by the compiler\nstring public publicString = \"This is a public function!\";\n\n// We create a public function that returns a string\nfunction publicFunction() public view returns (string memory) {\n    return publicString;\n}\n\n// functions inside of our contract can call this public function\nfunction functionOne() public view returns (string memory) {\n    return publicFunction();\n}\n\n}\n\n// using the \"is\" keyword we can use this to inherit functions\ncontract Child is Parent {\n\n// functions inherited from another contract can also call this function\nfunction functionTwo() public view returns (string memory) {\n    return publicFunction();\n}\n\n}\n</code></pre> <p>We can also call <code>publicFunction()</code> from within another smart contract if contract <code>Parent</code> is deployed on the blockchain:</p> <pre><code>// We first need to declare an interface to interact with another contract\ninterface ParentInterface {\n\n    // functions must be declared as external in the interface even if they are public in the contract they are being called from\n    function publicFunction() external view returns (string memory);\n}\n\ncontract AnotherContract {\n\n    // address 0xf8e81D47203A594245E36C48e151709F0C19fBe8 is where our Parent contract is stored (for example sake)\n    address parentAddress = 0xf8e81D47203A594245E36C48e151709F0C19fBe8;\n\n    function functionTwo() external view returns (string memory) {\n        return ParentInterface(parentAddress).publicFunction();\n    }\n}\n\n// functionTwo() =&gt; string : \"This is a public function!\"\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#private","title":"Private","text":"<p>Functions and variables labelled as <code>private</code> can only be accessed by the contract that has created the function. They cannot be passed on through inherited contracts or other contracts deployed on the blockchain. </p> <pre><code>contract Parent {\n\n// This does not have to be declared private for use in a private function\nstring private privateString = \"This is a private function!\";\n\nfunction privateFunction() private view returns (string memory) {\n    return privateString;\n}\n\n// This function will be able to call privateFunction()\nfunction functionOne() public view returns (string memory) {\n    return privateFunction();\n}\n}\n\n// Inherited contracts will not be able to inherit private functions\ncontract Child is Parent {\n\n// This function will not be able to call privateFunction() and produce an error\nfunction functionTwo() public view returns (string memory) {\n    return privateFunction(); // &lt;= error produced here\n}\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#internal","title":"Internal","text":"<p><code>internal</code> functions and variables are similar to <code>private</code> except they can be inherited by other contracts. However they cannot be called from other contracts using an interface:</p> <pre><code>contract Parent {\n\n// According to Solidity docs, this is the default visibility level for state variables therefore internal keyword is not neccesary\nstring internal internalString = \"This is a internal function!\";\n\nfunction internalFunction() internal view returns (string memory) {\n    return internalString;\n}\n\n// This will work\nfunction functionOne() public view returns (string memory) {\n    return internalFunction();\n}\n}\n\n// Inherited contracts will be able to call internal functions\ncontract Child is Parent {\n\n// This will also work\nfunction functionTwo() public view returns (string memory) {\n    return internalFunction(); \n}\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#external","title":"External","text":"<p><code>external</code> functions can only be called on the outside by an external user or contract. Variables cannot have the <code>external</code> visibility. </p> <pre><code>contract Parent {\n\n// Variables cannot be declared external\nstring externalString = \"This is an external function!\";\n\nfunction externalFunction() external view returns (string memory) {\n    return externalString;\n}\n\n// This will not work\nfunction functionOne() public view returns (string memory) {\n    return externalFunction();\n}\n}\n\n// Inherited contracts will also NOT be able to call external functions\ncontract Child is Parent {\n\n// This will NOT work\nfunction functionTwo() public view returns (string memory) {\n    return externalFunction(); \n}\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#state-mutability","title":"State Mutability","text":"<p>In some of our examples we have repeatedly seen the keywords <code>view</code> and <code>pure</code> used but did not discuss what these terms mean. When defining a function, we can declare whether the function is going to alter the state of the blockchain. If the function simply reads the state, we can declare the function with the <code>view</code> keyword. If the function does not read or write to the state, then we can declare this function as <code>pure</code> . </p> <p>Functions that are declared <code>view</code> or <code>pure</code> will not cost any gas if they are called externally as any computation can be done through the local node. However, if these functions are called internally by other functions, then this will incur a gas fee. </p>"},{"location":"solidity_tutorial_basics_part_3/#return-statement","title":"Return Statement","text":"<p>For a function to return something, you must specify the the <code>returns</code> keyword in the function declaration and include the type that is going to be returned inside brackets. You would then embed the <code>return</code> keyword before the value you would want to return.</p> <p>For instance, if you wanted to create a function to return a number:</p> <pre><code>uint number = 10;\n\n// we first use the returns key word and specify the type (in this case its uint)\nfunction retrieveNumber() public view returns (uint) {\n    // add the return keyword before the value you want to return\n    return number;\n}\n</code></pre> <p>If you want to return something that is of reference type (e.g. array, string), then you must also specify the data location (most of the times this will be <code>memory</code> ): </p> <pre><code>string myString = \"Hello World!\";\n\n// The memory keyword must be used here as string is a reference type\nfunction retrieveString() public view returns (string memory) {\n    return myString;\n}\n</code></pre> <p>If we want to return multiple values, we need to also include their type into the function declaration: </p> <pre><code>uint number = 10;\nstring numAsString = \"Ten\";\n\nfunction retrieveNumber() public view returns (uint, string memory) {\n    // We add brackets which will return a tuple of our values\n    return (number, numAsString);\n}\n\n// We can retrieve our values from our function like this\nfunction exampleOne() public view {\n    (uint a, string memory b) = retrieveNumber();\n}\n\n// or like this\nfunction exampleTwo() public view {\n    uint a;\n    string memory b;\n\n    (a,b) = retrieve();\n}\n</code></pre>"},{"location":"solidity_tutorial_basics_part_3/#modifiers","title":"Modifiers","text":"<p>Modifiers are special types of functions that can be \u201cadded\u201d to modify the behaviour of an existing function. One common use case for modifiers is to ensure certain conditions are met before the function being called can be invoked e.g. checking to see if user is admin or has required permissions. Whilst modifiers may not be necessary and any logic inside the modifier can be simply embedded into a function, its use makes the code more readable for other developers.  </p> <pre><code>uint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n\n// We create a modifier that will only allow the specified address to call a function\nmodifier onlyOwner() {\n    require(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n    // The \"_;\" is a special syntax that determines when you want the modifier to execute\n    _;\n}\n\n// We append the onlyOwner modifier to our function which will be executed first before storeNumber\nfunction storeNumber(uint num) public onlyOwner {\n    number = num;\n}\n\n// If we attempt to call the function using a different address than variable \"owner\", it will produce an error and revert the state\n</code></pre> <p>The location of <code>_;</code> is important as it instructs when the code inside the modifier should be run. Anything above the <code>_;</code> is ran before the function (which the modifier has been appended to) is itself executed. Any code that is below <code>_;</code> will be executed after the after the function has finished executing. </p> <p>We can use the previous example to demonstrate this concept:</p> <pre><code>/*\nWe will be calling storeNumber using address 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n\nDepending on where the _; is placed, will determine whether we can call storeNumber\n*/\n\nuint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n\nmodifier onlyOwner() {\n    // This line is going to be executed first before storeNumber\n    // Since the check comes first, we will not be able to call storeNumber\n    require(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n    _;\n}\n\nfunction storeNumber(uint num) public onlyOwner {\n    number = num;\n    // Lets change the address of the owner\n    owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n}\n\n// In this case we will not be able to call storeNumber as the require statment is executed first before we can change the owner variable\n</code></pre> <pre><code>/*\nBy placing the _; above the require statement we can change the address before running the require function\n*/\n\nuint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n\nmodifier onlyOwner() {\n    // we can now change the address of the owner before the require statement\n    _;\n    require(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n}\n\nfunction storeNumber(uint num) public onlyOwner {\n    number = num;\n    owner = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n}\n\n// In this example we will now be able call storeNumber using address 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2\n</code></pre> <p>Since the modifier is a function, we can also include function parameters just like normal functions. We will add a modifier to our original code with the condition that <code>number &gt; 10</code>. </p> <pre><code>uint256 number;\naddress owner = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;\n\nmodifier onlyOwner() {\n    require(msg.sender == owner, \"Permission Denied - Not the Owner!\");\n    // The \"_;\" is a special syntax that determines when you want the modifier to execute\n    _;\n}\n\nmodifier greaterThanTen(uint _number) {\n    require(_number &gt; 10, \"Number must be greater than 10!\");\n    _;\n}\n\nfunction storeNumber(uint num) public onlyOwner greaterThanTen(num) {\n    number = num;\n}\n\n// calling storeNumber(5) will produce an error and revert\n</code></pre>"}]}